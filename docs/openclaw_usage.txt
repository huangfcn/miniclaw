一、 OpenClaw 项目入门介绍
1. OpenClaw 项目开源与发展历程
        OpenClaw 的崛起不仅仅是一个开源项目的成功，它更被视为 2026 年 AI Native 开发范式的一次标志性事件。从代码生成到全球爆火，再到与巨头的博弈，其发展历程极具研究价值。
[Image]
1.1 缘起：AI 辅助编程的极致实验与“十天奇迹”
        OpenClaw 的诞生源于一个激进的实验。项目创始人 Peter Steinberger（知名 PDF SDK 提供商 PSPDFKit 的创始人）在退休后，试图验证“在不亲自编写代码的情况下，仅凭自然语言交互能否构建复杂系统”。
[Image]
- 极速构建： 2026 年 1 月初，Steinberger 借助 AI 编程工具，在短短 10 天内完成了项目原型的构建。据 GitHub 记录显示，其开发效率惊人，单日最高提交记录曾达到 1374 次。这种“暴力迭代”的开发模式，直接向开发者社区展示了 AI 辅助编程在工程化落地上的恐怖潜力。
- 核心动机： 项目发起的初衷并非商业化，而是为了对抗大模型厂商的“围墙花园”。Steinberger 希望创建一个能够深度访问本地文件系统、管理个人账号、且数据完全受控的“私人数字管家”，以此回应日益封闭的 AI 生态。
1.2 爆发：超越 Claude Code 的现象级增长
        项目开源后，迅速在 X（原 Twitter）和 Hacker News 上引发轰动，其热度增长曲线甚至打破了 GitHub 的历史记录。
[Image]
- 社区背书： 前特斯拉 AI 主管 Andrej Karpathy 率先在 X 上公开称赞该项目，将其定义为“个人数据自主权解放”的代表作。这一评价将 OpenClaw 从一个技术项目提升到了“数据主权”的意识形态高度。
[Image]
- 数据里程碑： 截止 2026 年 1 月底，项目 Star 数已突破 95k 大关，成为 GitHub 上增长最快的开源项目。其热度直接碾压了同期 Anthropic 官方推出的 Claude Code，成为 2026 年初无可争议的“Agent 之王”。
- 资本市场联动： 项目的火爆产生意想不到的连锁反应。由于大量开发者使用 Cloudflare Tunnel 进行内网穿透部署，导致 Cloudflare 流量激增，直接推动其股价单日上涨约 12%，市值短期内增加数十亿美元。
1.3 转折：商标风波与“Molt”重生
        2026 年 1 月 27 日，项目遭遇了来自 AI 巨头 Anthropic 的法律挑战，这一事件反而成为了项目破圈的关键转折点。
- 强制更名： Anthropic 法务部门指控项目原名“Clawdbot”及其龙虾吉祥物与“Claude”过于近似，涉嫌商标侵权。面对压力，Steinberger 当天宣布项目更名为 OpenClaw（意为“蜕壳”），并留下了那句著名的 Slogan：“New shell, same lobster soul”（新壳，旧魂）。
- 反脆弱效应： 这一更名事件被社区解读为“独立开发者对抗科技巨头”的象征。Hacker News 热门榜单迅速被相关讨论霸榜，甚至有工程师公开质问 Anthropic CEO：“难道你讨厌看到别人成功吗？”这种对抗情绪反而为 OpenClaw 带来了巨大的免费流量。
- 伴生混乱： 在更名交接的数小时内，旧的 GitHub 及 X 账号因释放过快，被黑客抢注并发布虚假的 $CLAWD 加密代币。该代币市值一度飙升至 1600 万美元后崩盘，虽然 Steinberger 迅速澄清并谴责，但这起插曲也侧面印证了项目惊人的关注度。
1.4 生态：中国市场的本土化适配与云端基建
        作为一个起初仅适配 Telegram 和 WhatsApp 的海外项目，OpenClaw 在中国市场的落地展现了惊人的“中国速度”。
- 云厂商抢滩： 2026 年 1 月 25 日，国内云厂商 UCloud（优刻得） 率先上线 OpenClaw 一键部署服务，并开发了企业微信（WeCom） 接口插件，解决了国内即时通讯工具的适配问题。随后，阿里云与腾讯云于 1 月 28 日紧跟其后，纷纷推出云端托管方案。
- 部署范式转变： 随着大厂入局，OpenClaw 的部署方式从早期的“本地 Docker 极客折腾”，迅速转变为“云端一键拉起”，极大地降低了普通开发者的使用门槛，使其真正具备了成为“国民级应用”的基础设施条件。
[Image]
2. OpenClaw核心功能与用户反馈
2.1 全能型移动开发与运维中心（Mobile Dev & DevOps）
这是目前最硬核且高价值的用法。用户不再依赖电脑，而是通过手机上的聊天软件（如 WhatsApp, Telegram, Discord）指挥 OpenClaw 完成复杂的软件开发和运维任务。
- “躺平”式开发：用户在床上或外出时，通过手机指令让 OpenClaw 构建网站、迁移服务器（如 Notion 迁移到 Astro）、甚至将应用提交到 Apple App Store 进行审核。
- 全自动 Debug 与部署：OpenClaw 可以被部署在服务器上（如 Hetzner, VPS），自主检查构建失败的日志，识别错误（如构建命令错误），修复代码，并重新部署，甚至在用户遛狗时通过语音完成这一切。
- 移动端 UI 构建：用户通过 WhatsApp 发送指令，OpenClaw 能生成 UI 界面并截图返回确认，甚至直接构建 macOS 菜单栏应用。
[Image]
 
[Image]
2.2 多智能体协作与“一人公司” (Multi-Agent Orchestration)
用户不再只是与一个机器人对话，而是将 OpenClaw 作为“指挥官”，调度一个由多个专门 Agent 组成的团队。
- 组建 AI 团队：有用户构建了包含 4 个 Agent 的团队，赋予它们不同的角色和性格（如魅力型领导 Milo、务实型商务 Josh、幽默型营销 Angela、内向型代码天才 Bob）。OpenClaw 负责统筹战略，其他 Agent 分别负责代码、营销和商务，并共享项目记忆。
- 自动化流水线：
  - 创意孵化：用户发送一个想法，OpenClaw将其记录为任务；夜间通过 Cron job 唤醒子 Agent 进行研究和实验；第二天早上生成决策报告供用户审批。
  - 开发测试流：OpenClaw 记录用户需求 -> 生成工作列表 -> 启动 Codex Agent 写代码 -> Claude Agent 审查 PR -> 生成测试文档。
[Image]
2.3 现实世界的事务谈判与执行 (Real-World Actions)
OpenClaw 展现出了极高的商业价值，它能通过浏览器、邮件和短信接口处理现实世界的复杂交易。
- 自动谈判与购买：OpenClaw 能够通过浏览器、邮件和 iMessage 同时与多个汽车经销商谈判，最终为用户买车节省了 4200 美元。
- 代办生活琐事：
  - 处理保险索赔：自主提交保险理赔申请并预约维修。
  - 超市下单：当家里缺东西时，自动登录超市账户（读取 1Password），通过 Beeper 读取短信验证码（MFA），并完成加购下单。
  - 旅行安排：在用户开车时，自动在邮件中查找航班信息，完成值机，并特意挑选靠窗座位。
[Image]
2.4 “第二大脑”与个性化信息流 (Second Brain & Content Curation)
OpenClaw 被用作极为高效的信息过滤器和知识管理工具。
- 信息聚合与去噪：每天早上提供简报，包含天气、行程、健康数据以及根据当前目标推荐的阅读材料。它还能监控 X (Twitter) 书签、Hacker News 或 YouTube 视频，生成摘要并与用户讨论，甚至根据用户习惯过滤垃圾邮件。
- 知识库同步：将研究成果、会议记录、健康数据自动整理并同步到 Notion、Obsidian 或 Tana 等笔记软件中，构建自动更新的个人知识库。
- 技能学习：有用户让 OpenClaw 根据自己的水平量身定制中文学习课程，包含语音合成和发音反馈。
[Image]
2.5 智能家居与硬件深度集成 (Smart Home & Hardware)
用户通过 OpenClaw 打通了物理世界与数字世界的边界。
- 硬件管家：用户将 OpenClaw 部署在树莓派或 Mac Mini 上，让其拥有独立的“身体”和账户。它可以控制 HomePod、Alexa 设备，甚至校准复杂的电力监测硬件（IoTawatt）。
- 家庭与健康中枢：
  - 膳食规划：制定全年膳食计划，根据天气预报调整菜单（如适合烧烤的日子），并按超市货架顺序生成购物清单。
  - 健康监控：整合 WHOOP 或 Garmin 的数据，生成运动热力图，甚至在用户熬夜时发信息提醒。
- 趣味硬件：有用户购买了全息立方体（Holo cube）作为 OpenClaw 的显示器，将其变成这就类似“电子宠物”的存在。
2.6 其它趣味与创意用法
- 社交替身：在群聊中模仿用户的语气与朋友聊天（用户评价“极其搞笑”）。
- 多机器人社交：两个不同用户的 OpenClaw 可以在同一个 WhatsApp 群组中相互协作和交流。
- 媒体创作：自动去除视频水印，甚至从零生成拥有特定人设（如“凌乱头发、穿着灰色卫衣”）的 UGC 视频博主内容。
- 音乐分析：从歌曲中提取音轨、生成 GIF 并输出和弦 PDF。
总结：目前的 OpenClaw 已经从单一的聊天机器人进化为个人生活的操作系统（OS）。其核心价值在于**“连接”**——它连接了代码库、日历、笔记软件、智能家居、浏览器以及现实世界的服务，并通过自然语言（甚至语音）让用户能够随时随地进行复杂的控制和创造。
3. OpenClaw 爆火背后的时代契机：从 AutoGPT 到“贾维斯时刻”
        OpenClaw（原 Clawdbot）在 2026 年初的爆发并非偶然。在 AI 发展的历史长河中，它不仅是一个 GitHub 项目的胜利，更是技术成熟度曲线（Gartner Hype Cycle）与用户心理预期曲线在特定时间点的完美交汇。
        要理解 OpenClaw 为何能在这个冬天点燃全球开发者的热情，我们需要将视角拉长，回溯智能体（Agent）发展的三个关键里程碑，并深入剖析支撑这一现象背后的“铁三角”：用户认知的成熟、底层模型能力的质变、以及工程化基础设施的完备。
3.1 历史的回响：智能体演进的“三部曲”
        回顾过去三年，Agent 领域经历了三次标志性的“爆发”，每一次爆发都对应着特定的技术瓶颈突破和产品形态的跃迁。OpenClaw 的出现，正是站在了 AutoGPT 和 Manus 的肩膀上，完成了一次从“玩具”到“工具”，再到“伙伴”的终极跨越。
第一阶段：概念验证期 —— AutoGPT 与 GPT-3.5 的“死循环” (2023)
        2023 年，AutoGPT 的横空出世让“自主智能体”的概念第一次进入大众视野。那是一个充满狂热与粗糙的时代。
- 爆发契机： GPT-3.5 的发布让人们第一次看到了 LLM 具备一定的推理能力，OpenAI API 的开放使得“循环调用”成为可能。
- 核心痛点： 限于当时模型的能力，AutoGPT 经常陷入著名的“思考死循环”（Loop of Death）。模型无法准确判断任务何时结束，或者在执行复杂任务链时丢失上下文。
- 历史定位： 它是一个伟大的概念验证（POC）。它证明了“目标分解-自动执行”的逻辑是成立的，但受限于模型智商（推理能力不足）和工具生态（缺乏标准接口），它更像是一个极客手中的昂贵玩具，而非生产力工具。
[Image]
第二阶段：交互觉醒期 —— Manus 与“通用智能体”的初体验 (2025)
2025 年初，Manus 的走红标志着 Agent 进入了第二阶段。
- 爆发契机： 此时用户已经不再满足于 Chatbot 的“你问我答”，开始渴望 AI 能“替我办事”。同时，模型能力提升到了 GPT-4 Turbo 和 Claude 3.5 级别，规划能力大幅增强。
- 核心痛点： 虽然 Manus 展示了令人惊艳的演示视频，但在实际落地中，依然面临着封闭生态和高昂成本的问题。它更多是以 SaaS 产品的形态出现，而非开发者可自由掌控的基础设施。
- 历史定位： 它是用户认知的启蒙者。Manus 让普通用户接受了“把电脑控制权交给 AI”这一激进理念，为后来的 Agent 普及铺平了心理障碍。
第三阶段：生态成熟期 —— OpenClaw 与“贾维斯”的实质化 (2026)
        2026 年，OpenClaw 的出现不仅仅是因为它开源，更是因为它代表了**“技术+生态+形态”的完全体**。它不再是单一技术的单点突破，而是整个 AI 产业链成熟后的集大成者。它解决了前两代产品的核心遗留问题：稳定性、可控性和扩展性。
3.2 时代契机一：底层模型能力的“临界突破”
        OpenClaw 之所以能做到“即插即用、稳定执行”，最根本的原因在于 2025 年底至 2026 年初，底层大模型（Foundation Models）发生了质的飞跃。如果没有这些地基，上层的 Agent 建筑依然会是空中楼阁。
- 推理能力的飞跃（Claude 4.5 / Gemini 3.0 / GPT-5.2）：
- 在此之前，模型在执行长链条任务（Long-chain Tasks）时，往往会在第 3 或第 4 步开始“幻觉”或偏离目标。但随着 Claude 4.5 和 GPT-5.2 的发布，模型的逻辑推理能力（Reasoning）达到了新的高度。它们能够精准地理解复杂指令，并在长达数十轮的对话中保持目标的一致性。这意味着 OpenClaw 在执行“读取文件 -> 分析数据 -> 编写代码 -> 运行测试 -> 修复 Bug”这样复杂的闭环任务时，成功率从 60% 飙升至 95% 以上。
- 超长上下文窗口（Infinite Context）：
- OpenClaw 的核心体验是“全知全能”，这依赖于模型对上下文的记忆。现在的旗舰模型普遍具备 200k 甚至 2M 的有效上下文窗口，且“大海捞针”（Needle In A Haystack）的召回率接近 100%。这使得 OpenClaw 可以一次性读取整个项目的代码库，或者理解用户过去几个月的所有偏好，而不会遗忘。
- 原生工具调用（Native Tool Calling）：
- 早期的 Agent 需要通过复杂的 Prompt Engineering 来诱导模型输出 JSON 格式的工具指令，极其不稳定。而现在的模型（如 Gemini 3.0）在训练阶段就强化了 Function Calling 能力。模型知道何时该查网、何时该读文件、何时该运行 Python 脚本，这种“肌肉记忆”般的工具调用能力，是 OpenClaw 能够流畅运行的基石。
3.3 时代契机二：工程化技术的成熟与标准化
仅有聪明的模型是不够的，OpenClaw 的成功还得益于 Agent 开发生态的“工业化”。
- MCP（Model Context Protocol）的普及：
- 这是 OpenClaw 能在 10 天内开发完成的关键秘密。在过去，让 AI 连接本地文件系统、数据库或第三方 API，需要编写大量的胶水代码。而 MCP 协议 的出现，相当于为 AI 世界制定了 USB 标准。OpenClaw 只需要通过 MCP 接口，就能无缝挂载各种数据源和工具。开发者不再需要造轮子，而是像搭积木一样组装能力。
  - 深度解析： MCP 解决了 Agent 的“最后一公里”连接问题，让数据流动变得标准化、低成本。
- Agent Skills 与工具链的完善：
- 现在的开发者社区已经沉淀了海量的 Agent Skills（智能体技能库）。从操作 Excel、PDF 处理，到调用 Google Search、GitHub API，现成的工具库琳琅满目。OpenClaw 实际上是一个高效的调度器，它灵活地调用这些成熟的技能模块，而非从零构建。
- 状态管理与记忆机制：
- 相比于 AutoGPT 简陋的文件存储，OpenClaw 利用了更成熟的向量数据库（Vector DB）和图数据库（Graph DB）技术来管理长期记忆。这使得它不仅能记住你在说什么，还能理解实体之间的关系，真正做到了“越用越懂你”。
3.4 时代契机三：产品形态的终极进化——Chat-Native
OpenClaw 最具破坏力的创新，在于它不仅拥有独立的 Web UI，直接寄生于用户最常用的 IM 软件（Telegram, WhatsApp, WeCom）之中。这不仅是 UI 的改变，更是交互逻辑的革命。
- 从“访问网站”到“随时待命”：
- 传统的 Agent（如 ChatGPT 网页版）是一个“目的地”，你需要主动去访问它。而 OpenClaw 是一个“随行者”。它存在于你的联系人列表中，就像你的同事或助理一样。这种 Always-on 的状态，完美契合了用户对“贾维斯”的想象——无处不在，随叫随到。
- 无限对话流（Infinite Conversation）：
- OpenClaw 打破了“Session”（会话）的概念。它不再是一次性的问答，而是一场永不结束的对话。通过对历史记录的智能摘要和检索，它能在一个持续数月的对话流中，不断累积对用户的认知。这种形态极大地降低了用户的使用心理负担，让交互变得像发微信一样自然。
- OS 级别的权限下放：
- OpenClaw 敢于触碰传统 SaaS 不敢触碰的禁区——本地文件系统读写权限。它运行在用户的私有环境（或私有云）中，直接操作真实文件。这种“高风险、高回报”的设计，直击开发者痛点。用户不再需要把代码复制粘贴到对话框里，而是直接对 OpenClaw 说：“帮我把 src 目录下的所有 Python 脚本重构一遍”，它就能直接修改文件。这种侵入式的交互，带来了前所未有的效率提升。
3.5 我们在新范式中的位置
OpenClaw 的爆火是一个信号，宣告了 AI Native 时代从“尝鲜”正式进入“深水区”。无论是普通用户还是开发者，都需要调整自己的坐标系。
对普通用户的忠告：拥抱“一人公司”的思维
OpenClaw 的出现意味着“执行力”的贬值和“决策力”的升值。
- 学会“管理”而非“操作”： 未来，你不再是 Word 或 Excel 的操作员，而是 AI 智能体的经理（Manager）。你需要学会如何下达清晰的指令（Prompting）、如何设定验收标准（Review）、以及如何通过 OpenClaw 调度资源。
- 建立信任边界： OpenClaw 拥有极高的权限，这意味着你必须具备基本的安全意识。理解什么是 Sandbox（沙箱），理解授权的风险，是每个数字公民的必修课。
- 人机协作常态化： 不要试图与 AI 对抗，也不要完全依赖 AI。最好的状态是 Co-pilot（副驾驶） 模式。你负责把握方向盘（战略与创意），OpenClaw 负责踩油门和看导航（执行与数据处理）。
对开发者的忠告：OpenClaw 是新时代的“Hello World”
如果你是一名开发者，千万不要只把 OpenClaw 当作一个好用的工具，它更是你需要深入解构的教科书。
- 理解“胶水”的艺术： 未来的开发工作，写核心算法的机会将变少，更多的是编写 Orchestration Logic（编排逻辑）。你需要学习如何利用 MCP 协议，将分散的模型、工具、数据源连接起来。OpenClaw 的源码就是最佳的参考范例。
- 关注架构而非模型： 模型会不断迭代（GPT-6, Claude 5 即将到来），但 Agentic Architecture（智能体架构） 是相对稳定的。学习 OpenClaw 是如何处理任务拆解、记忆检索、错误重试的，这些设计模式（Design Patterns）是未来软件工程的核心资产。
- 从“构建应用”转向“构建智能体”： 传统的 CRUD（增删改查）应用将逐渐式微。未来的应用将以 Agent 的形态存在——它有性格、有记忆、能主动交互。OpenClaw 展示了如何通过自然语言接口（NLI）替代图形用户接口（GUI），这是下一个十年的交互革命。
[Image]
二、5分钟零门槛免费上手OpenClaw
1. MacOS主流部署方案
[Image]
首先是MacOS上如何安装OpenClaw。可以说截止目前，OpenClaw对Mac系统是最友好的，不仅安装流程简单、运行稳定，甚至还推出了专门的MacOS App。
在Mac中安装OpenClaw，首先我们需要先安装Node.js基础运行环境，登陆nodejs.org即可下载对应操作系统的安装包，
[Image]
具体的Node.js的安装过程非常简单，根据提示，一路点击下一步即可，安装完成后按住command+空格，搜索并打开终端，先输入node -v确认Node.js的版本号，需要确保大于V22，
node -v
[Image]
然后输入npm install命令，来安装OepnClaw，
npm install -g openclaw@latest
[Image]
安装完成后，即可输入onboard命令进入到Agent设置环节，
openclaw onboard
而如果希望后台长期运行且开机自动启动，则需要在命令后面加上install命令，
openclaw onboard --install-daemon
进入设置页面后，首先风险警告选择yes continue继续，
[Image]
然后选择QuickStart快速开始，
[Image]
然后选择模型供应商，新版的OpenClaw对中国开发者及其友好，加入了很多国产模型供应商，如Kimi、MiniMax等模型，
[Image]
而且为了争夺流量入口，也有很多模型相继为OpenClaw提供了免费调用额度，例如在1月30日的更新中，Kimi K2.5就加入了免费全家桶。
[Image]
而国内完全免费且较为稳定的是Qwen App的接口，即调用千问的App来进行对话。这里我们选择Qwen，
[Image]
然后选择授权，
[Image]
然后就会自动弹出授权页面，如果没有注册，还会提示先进行注册再授权，然后点击确认即可完成授权
[Image]
[Image]
然后选择默认模型即可，
[Image]
这里需要说明的是，如果要选择其他免费模型，就需要在选择模型供应商部分先选择Skip for now，
[Image]
然后就能看到现在OpenClaw各免费模型的名字，大家可以任意选择，也可以选择比如kimi-coding模型，
[Image]
然后选择kimi-2.5模型作为默认模型，
[Image]
不管怎样，选择完模型之后，即可进一步选择channel，也就是选择允许接入的即时通信软件。目前国内支持的比较好的只有iMessage，但应用面不广，下一小节我们还会介绍如何通过插件接入企微和飞书，因此这里我们先选择跳过，
[Image]
然后进入到Skills安装页面，稍后会有单独的一个小节来介绍OpenClaw的Skills，因此这里可以先直接跳过，
[Image]
然后我们选择让模型能够进行会话级的长期记忆，
[Image]
然后就会开始自动安装，
[Image]
而当安装结束后，即可选择对话方式，这里我们选择TUI，即同步命令行和Web页面内容进行对话，
[Image]
选择完成后即可进入到对话页面，首次登陆时会自动给OpenClaw发送一条Wake up，my friend信息，能够看到模型即时回复的消息，
[Image]
此外，也可以在命令行中看到回复内容。
[Image]
2. Windows部署流程
WSL2 是 Windows Subsystem for Linux 2 的缩写，顾名思义，它是一个允许你在 Windows 系统中直接运行完整的 Linux 操作系统环境（比如Ubuntu系统）的工具，而无需传统的虚拟机。出于系统架构与兼容性考虑，以及方便安装后台守护进程，Windows的同学需要提前安装好WSL2。
下载WSL2的过程并不复杂， 但首先需要确认自己的Windows系统版本是否满足要求。大家可以直接在设置、系统、系统信息中查看Windows版本，需要Windows 11 或至少 Windows 10 版本 1903 或更高版本才可安装WSL2。
[Image]
然后搜索命令提示符，右键选择以管理员身份运行。
[Image]
然后输入wsl --install命令进行下载，
[Image]

wsl --install
等待下载完成后，即可再输入wsl --list --verbose查看已经下载的WSL2的版本号，
wsl --list --verbose
通常来说，只要看到Ubuntu系统，就说明已经安装成功了。
[Image]
而如果你的Ubuntu虚拟系统还处于关闭状态，则需要进一步输入如下命令开启Ubuntu环境。开启后会自动进入到Ubuntu系统的命令行中，
wsl -d Ubuntu
[Image]
然后输入如下命令安装curl工具，
sudo apt-get update && sudo apt-get install -y curl
[Image]
然后输入如下命令安装v 22最新版Node.js。
[Image]
这里首先需要输入fs命令升级软件源列表：
curl -fsSL https://deb.nodesource.com/setup_22.x | sudo -E bash -
然后使用apt-get install命令进行安装，
sudo apt-get install -y nodejs
[Image]
等待安装完成后即可输入node -v查看安装版本，显示大于22.0版本即说明安装成功。
node -v
[Image]
接下来即可使用npm工具来安装OpenClaw项目了。由于OpenClaw是一个纯粹的javascript和typescript项目，所以只需要一行命令即可完成安装，非常简单。
[Image]
这里我们输入npm install命令，即可完成OpenClaw完整项目安装。
sudo npm install -g clawdbot@latest
3.基于阿里云的Moltbot部署流程
- 项目主页：https://www.aliyun.com/benefit/scene/moltbot?spm=5176.42028462.J_4VYgf18xNlTAyFFbOuOQe.1.e939154a2hly3N&scm=20140722.M_10948942.P_120.MO_1774-ID_10948942-MID_10948942-CID_36705-ST_15536-V_1
[Image]
1.1 选购轻量服务器
- 地址：https://swasnext.console.aliyun.com/buy?spm=5176.454194655176.J_L02u6VphiK2DqbAEtTYRj.1.79434859LY5HTz&regionId=us-east-1&planId=swas.s.c2m2s40b1.linux&imageId=bd45493af84846deb5dcd3fca6c1a1d9&amount=1&duration=12&autoRenew=false#/
[Image]
 
[Image]
 
[Image]
 
[Image]
1.2 创建阿里百炼API-KEY
[Image]
地址：https://bailian.console.aliyun.com/cn-beijing/?tab=model#/model-market
[Image]
 
[Image]
 
[Image]
 
[Image]
 
[Image]
 
[Image]
1.3 开启服务
[Image]
 
[Image]
 
[Image]
 
[Image]
三、OpenClow基础架构与使用场景介绍
[Image]
1. OpenClaw网关系统与多Node连接
OpenClaw 的网关（Gateway）是整个系统的中枢神经。正如我们在之前关于“安装”和“节点”的讨论中所见，无论您有多少个客户端设备（节点），它们都必须连接到这个唯一的“大脑”才能工作。从功能层面来看，OpenClaw 网关主要扮演了以下四个核心角色：
1.1 通信枢纽：统一管理渠道与节点
网关是一个长运行的单一进程，它独占并管理着所有的外部连接,。
- 多渠道集成（Bridge）： 网关负责直接连接第三方通信平台。它通过不同的协议适配器将这些平台“桥接”到 OpenClaw 内部：
  - WhatsApp：使用 Baileys 协议库处理 WhatsApp Web 协议,。
  - Telegram：通过 grammY 处理 Bot API 消息,。
  - Discord：通过 channels.discord.js 处理,。
  - iMessage：在 macOS 上通过本地 imsg CLI 集成,。
  - 以及 Mattermost、Slack 等插件支持,。
- WebSocket 控制平面： 网关运行在 ws://127.0.0.1:18789（默认），作为 WebSocket 服务器等待节点（Nodes） 的连接。无论是您的 macOS App、iOS/Android 手机，还是 WebChat 界面，都通过这个 WebSocket 管道与网关交换指令和数据,。
1.2 AI 编排器：RPC 桥接与工具流
网关并不直接“思考”，而是负责协调“思考者”（AI Agent）与外界的交互。
- RPC 代理（Agent Bridge）： 网关通过 RPC 模式 连接到 OpenClaw 的核心编程智能体 Pi,。这是目前唯一的官方 Agent 路径（旧的直连路径已被移除）,。网关负责将用户的自然语言消息转发给 Pi，并将 Pi 的响应（文本或代码）传回给用户。
- 工具流式传输（Tool Streaming）： 当 Pi 需要执行复杂任务（如写代码、画图）时，网关支持实时的工具执行流,。这意味着 AI 正在写的代码会实时流式传输经过网关，最终到达您的节点屏幕上。
- Canvas 托管服务（Canvas Host）： 这就是我们在上一个问题中提到的核心功能。网关内部内置了一个 HTTP 文件服务器，默认运行在端口 18793,。
  - 功能：专门用于托管 AI 生成的 Web 界面（Canvas）。
  - 流程：网关生成 URL http://<gateway-host>:18793/__openclaw__/canvas/，并指令节点去加载这个页面,。
1.3 会话与上下文管理器
网关负责维护对话的状态和逻辑，确保 AI 知道“在跟谁说话”以及“上下文是什么”。
- 会话路由（Session Management）：
  - 私聊合并：网关会将来自同一用户的私聊消息（Direct Chats）合并到一个共享的 main 会话中，这意味着您在 WhatsApp 和 Telegram 上跟 AI 说的私房话是互通的,。
  - 群组隔离：群组聊天的上下文是独立隔离的，互不干扰,。
- 多智能体路由（Multi-agent Routing）： 网关支持将不同的提供商账户或 Peers 路由到独立的 Agent 工作区（Workspace），实现更复杂的任务分发,。
- 媒体处理： 网关具备处理富媒体的能力，支持发送和接收图片、音频、文档，甚至包含语音笔记的转录钩子（Hook）,。
1.4 网络与安全守卫
作为本地运行的服务，网关在网络配置上采用了“安全优先”的设计。
- 回环优先（Loopback-first）： 网关默认绑定在 127.0.0.1，仅允许本机访问，以防止意外暴露给公网,。
- 远程访问支持： 如果您需要远程连接（例如出门在外用手机 App 连接家里的电脑），网关支持通过 Tailscale VPN 或 SSH 隧道进行安全绑定，并强制要求使用 Token 进行身份验证,。
- OAuth 认证： 对于接入 Anthropic (Claude) 或 OpenAI 等需要授权的服务，网关负责处理 OAuth 流程,。
可以把 OpenClaw 网关想象成一个超级管家：
1. 他手里拿着所有通讯软件的账号（通信枢纽）。
2. 他耳朵里戴着耳机连接着超级大脑 Pi（RPC 代理）。
3. 他负责把超级大脑的想法画成图纸（Canvas Host）。
4. 他最后把结果分发给您手里的各个屏幕（节点管理）。
[Image]
 
[Image]
 
[Image]
2. OpenClaw内置工具
1.2 核心内置工具库
        OpenClaw 之所以强大，不仅是因为它有一个“大脑”（网关+Pi 智能体），更因为它为这个大脑配备了一整套“手脚”和“感官”。这些手脚就是内置工具 (Tools) 和 技能 (Skills)。OpenClaw 的核心理念是 Agentic（代理自主性），这意味着它不只是陪聊，而是通过调用以下工具来执行任务。OpenClaw 提供了一系列强大的原生工具，主要分为以下几类：
A. 系统执行与编程工具 (The "Hands")
这是 OpenClaw 作为 "Coding Agent" 的核心能力。
- Exec Tool (命令执行)： 允许 Agent 在宿主机的安全沙箱（Sandbox）中运行 Shell 命令。这意味着它可以安装依赖、运行脚本、或者管理文件。
- apply_patch Tool (代码补丁)： Agent 可以通过这个工具直接修改文件内容。配合 Exec Tool，它就具备了“自我修复”和“编写程序”的能力——先写代码，运行报错，然后自己打补丁修复。
- Background Exec (后台进程管理)： 允许 Agent 启动并管理长运行的后台进程（例如启动一个临时的 Python 服务器来托管服务）。
[Image]
 
[Image]
 
[Image]
B. 浏览器与网络工具 (The "Eyes")
- Managed Browser (托管浏览器)： OpenClaw 内置了对 Headless Browser（无头浏览器）的管理能力。Agent 可以“打开”一个网页，读取内容，甚至进行登录操作。
- Chrome Extension (浏览器扩展)： 配合浏览器工具，Agent 可以更深入地与网页交互，抓取数据或自动化操作 Web 任务。
[Image]
C. 硬件感知工具 (The "Senses")
当您连接了手机（iOS/Android Node）或使用 macOS App 时，这些设备会将硬件能力暴露为工具供 Agent 调用：
- Camera Capture (摄像头)： Android Node 独占功能。您可以让 Agent 控制手机拍照。例如问它“看一眼我桌子上有什么？”，它会调用手机摄像头拍照并进行视觉分析。
- Location (定位)： Agent 可以获取设备当前的地理位置，用于处理基于位置的服务（如“查询我附近的天气”）。
- Voice Wake / Audio (语音)： 支持语音唤醒和语音笔记的处理，甚至可以通过 Voice Call Plugin 拨打语音电话。
[Image]
D. 自动化与调度工具 (The "Clock")
- Cron Jobs (定时任务)： 这不是一个简单的闹钟，而是允许 Agent 自己注册定时任务。Agent 可以决定“每小时检查一次股票价格”，并在后台自动执行。
- Hooks (钩子)： 包括 Gmail PubSub（邮件监听）和 Webhooks，让 Agent 能对外部事件（如收到新邮件）做出反应。
[Image]
1.2 工具的组合使用效果
当单一工具被组合使用时，OpenClaw 就从“聊天机器人”进化成了“全能数字管家”。以下是几个基于其工具链的神奇应用场景：
✨ 场景一：全自动化的“新闻简报员”
- 组合工具：Cron Jobs + Managed Browser + Canvas
- 流程：
  1. 您对 OpenClaw 说：“每天早上 8 点给我一份 AI 行业的新闻摘要。”
  2. Agent 使用 Cron Jobs 设定定时任务。
  3. 每天早上 8 点触发，Agent 使用 Managed Browser 访问 Hacker News 或 TechCrunch，抓取最新头条。
  4. Agent 总结内容，并利用 Canvas 生成一个精美的 HTML 卡片（包含新闻标题、摘要和链接）。
  5. 最后通过 WhatsApp 推送到您的手机上。
✨ 场景二：具备“视觉”的现实世界助手
- 组合工具：Camera Capture (Android) + Exec Tool (Python/Vision API)
- 流程：
  1. 对着手机上的 OpenClaw 说：“帮我看看冰箱里的食材能做什么菜。”
  2. Agent 调用 Camera Capture 拍一张冰箱内部的照片。
  3. Agent 分析图片内容（识别出鸡蛋、西红柿、青椒）。
  4. Agent 搜索菜谱，并直接生成一份烹饪指南发送给您。
✨ 场景三：交互式“Coding Buddy” (编程搭档)
- 组合工具：Exec Tool + apply_patch + Canvas + Background Exec
- 流程：
  1. 说：“写一个贪吃蛇游戏，要能玩的。”
  2. Agent 使用 Exec Tool 创建 HTML/JS 文件。
  3. Agent 使用 Background Exec 或 Canvas Host 托管这个游戏。
  4. Agent 将链接通过 Canvas 弹窗发给您。
  5. 您玩了一把发现蛇跑得太快，说：“太快了，慢一点。”
  6. Agent 使用 apply_patch 修改代码中的速度参数，实时刷新您的游戏界面。
场景四：基于位置的智能提醒
- 组合工具：Location + Channel Routing
- 流程：
  1. 设定规则：“当我离开家（基于 GPS）时，提醒我买牛奶。”
  2. Agent 间歇性通过 Location 工具检查状态。
  3. 一旦检测到位置变化，立刻通过 WhatsApp 发送提醒消息。
OpenClaw 的核心魅力在于：它不预设功能，而是提供“元能力”。 通过 Exec（执行）、Browser（浏览）、Camera（视觉）和 Cron（时间）这四大维度的工具，您可以像搭积木一样，用自然语言构建出无限可能的自动化工作流。
3.插件与Skills系统
在 OpenClaw 的架构中，如果说 Tools（工具） 是 AI 的“手和眼”（如浏览器、摄像头），那么 Plugins（插件） 和 Skills（技能） 就分别代表了它的“耳朵/嘴巴”和“职业专长”。这两者共同扩展了 OpenClaw 的边界，但侧重点完全不同：插件主要用于扩展网关的连接能力，而技能主要用于扩展 Agent 的任务逻辑。
3.1 Plugins (插件系统)：扩展网关的“感官”与“触角”
插件运行在 Gateway（网关） 层，主要用于增加 OpenClaw 支持的新通信协议或底层功能。它解决的是“OpenClaw 能在哪里说话”以及“能处理什么样的新信号”的问题。
根据文档，目前的插件主要分为两类：
A. 渠道扩展插件 (Channel Plugins)
OpenClaw 核心支持 WhatsApp、Telegram 等，但通过插件可以支持更多平台：
- Mattermost Plugin： 这是一个典型的渠道插件。它允许 OpenClaw 通过 Bot Token 和 WebSocket 事件接入 Mattermost 聊天平台，使其像原生渠道一样工作,。
- Zalo Personal Plugin： 增加了对越南流行社交软件 Zalo 的支持（个人号集成）,。
B. 功能增强插件 (Capability Plugins)
这类插件赋予网关处理特殊媒体流的能力：
- Voice Call Plugin（语音通话插件）： 它让 AI 不仅仅能发语音条（Audio Note），还能真正地拨打和接听电话。这极大地扩展了交互场景，让 Agent 可以充当电话接线员或语音助手。
[Image]
3.2 Skills (技能系统)：赋予 Agent “职业专长”
技能运行在 Agent（智能体） 层，通常是一组预设的逻辑、提示词（Prompts）或特定工作流的集合。它解决的是“OpenClaw 擅长做什么工作”的问题。
A. 什么是 Skill？
Skill 是对基础 Tools 的高级封装。
- ClawHub：之前提到了 ClawHub,，这是 OpenClaw 的技能市场或中央仓库，用户可以在这里下载或分享社区构建的技能。
[Image]
- 配置化：技能通常通过配置文件（Skills Config）来管理,，这意味着您可以为不同的 Agent 实例加载不同的技能包。
[Image]
B. 典型案例：Blogwatcher (博客观察者)
文档特别致谢了一个名为 Blogwatcher 的技能（由贡献者 Maxim Vovshin 开发）,。
- 功能推测：基于其名称和 OpenClaw 的工具能力（Cron Job + Browser），这个技能很可能封装了一套自动化流程：定期扫描指定的技术博客，提取新文章，并生成摘要发送给用户。
- 意义：用户不需要每次都对 AI 说“请打开浏览器去检查这个网站”，而是直接安装“Blogwatcher”技能，Agent 就自动学会了这项工作。
[Image]
3.3 系统对比与协作
我们可以把 OpenClaw 比作一个公司员工：
特性
Tools (内置工具)
Plugins (插件)
Skills (技能)
比喻
手、眼、腿
手机、对讲机、电话
会计证、厨师证、驾驶证
作用
执行具体动作（如：点击网页、拍照）
建立新的连接通道（如：接入 Mattermost）
定义复杂的业务流程（如：监控博客、日报生成）
运行位置
核心沙箱 / 节点
网关 (Gateway) 进程
Agent 逻辑层 / 配置
例子
Managed Browser, Exec
Mattermost, Voice Call
Blogwatcher, ClawHub
通过组合这三个系统，我们可以定制出完全不同的 AI 角色：
- 场景一：企业客服
  - Plugin：安装 Mattermost 插件（接入公司内网聊天） + Voice Call 插件（接听客户电话）。
  - Skill：加载“FAQ 回答”技能。
  - 效果：一个既能回内网消息，又能接听电话的 AI 客服。
- 场景二：市场情报官
  - Tool：使用内置的 Browser 和 Cron。
  - Skill：安装 Blogwatcher 技能。
  - 效果：每天自动向您的 WhatsApp 推送竞争对手的最新动态。
这就是 OpenClaw 的扩展哲学：网关搭台（Plugins），工具干活（Tools），技能通过逻辑（Skills）将它们串联成价值。
4.OpenClaw人格与记忆管理系统
[Image]
Clawdbot 的记忆系统设计非常独特且具有高度的工程实用性。它放弃了传统的云端数据库，转而采用**“本地 Markdown 文件 + 嵌入式 SQLite 向量库”**的混合架构。
[Image]
4.1 基础功能 (Basic Functions)
Clawdbot 的记忆系统旨在解决 LLM 上下文窗口有限（Context Window）和会话易失性的问题，将记忆分为“短期上下文”和“长期持久化记忆”。
- 双层存储架构：
  - 每日流水账 (Layer 1 - Daily Logs)：存储在 ~/clawd/memory/YYYY-MM-DD.md。这是仅追加（Append-only）的每日笔记，Agent 会在这里记录当天的临时想法、任务进度和观察。
  - 长期知识库 (Layer 2 - Long-term Memory)：存储在 ~/clawd/MEMORY.md。这是经过策划的持久知识，包含用户偏好、重要决策、项目核心事实等。
- 主动检索工具：
  - memory_search：Agent 在回答关于过去决策、日期或特定事实的问题前，必须调用的工具。它执行语义搜索，返回相关片段。
  - memory_get：在搜索到相关文件路径后，Agent 使用此工具读取文件的具体行内容。
- 显式写入：
  - 没有专门的“写入记忆”工具，Agent 使用标准的文件操作工具（write, edit）直接修改上述 Markdown 文件。系统会自动监测文件变化并更新索引。
[Image]
2.2 核心特性 (Core Features)
Clawdbot 的设计哲学是“透明性”和“本地优先”，这使其区别于大多数封装好的 AI 产品。
- Markdown 原生 (Markdown-Native)：
  - 记忆就是普通文本文件。这意味着用户可以直接打开 IDE 编辑记忆，进行版本控制（Git），或者手动修正 Agent 的错误记忆。
- 混合搜索策略 (Hybrid Search)：
  - 为了解决单一搜索的缺陷，Clawdbot 采用了 70% 向量搜索 (Semantic) + 30% BM25 关键词匹配 (Keyword) 的加权策略。
  - 优势：既能通过语义找到“那个数据库相关的决定”（向量优势），也能精准定位特定的 ID 或变量名（关键词优势）。
- 多智能体隔离 (Multi-Agent Isolation)：
  - 不同的 Agent（如“工作助理”和“个人助理”）拥有完全独立的 Workspace 和 SQLite 索引文件。默认情况下，它们无法读取彼此的记忆，实现了上下文的物理隔离。
- 上下文压缩与“刷盘” (Compaction & Flush)：
  - 当对话接近 Token 极限（如 200k）时，系统会触发压缩，将旧对话总结为摘要。
  - 关键特性：在压缩发生前，系统会触发**“记忆刷盘” (Pre-compaction Flush)**，提示 Agent：“快要遗忘旧对话了，请将重要信息写入磁盘文件。”这防止了重要细节在压缩过程中丢失。
[Image]
四、【实战】AI数字员工—AI HR开发实战
1. 安装飞书插件
openclaw --version
openclaw plugins list
[Image]
安装飞书插件
openclaw plugins install @m1heng-clawd/feishu
[Image]
重启OpenClaw
openclaw gateway restart
[Image]
进入飞书开发者控制台：https://open.feishu.cn 并进行设置：
[Image]
 
[Image]
创建机器人
[Image]
 
[Image]
 
[Image]
需要勾选的权限如下：
[Image]
 
[Image]
 
[Image]
 
[Image]
 
[Image]
提交发布申请
[Image]
 
[Image]
openclaw config set channels.feishu.appId "cli_a9..."
openclaw config set channels.feishu.appSecret "EDm..."
openclaw config set channels.feishu.enabled true
openclaw config set channels.feishu.connectionMode websocket
openclaw gateway restart
[Image]
在飞书开放平台的应用后台，进入 事件与回调 页面：
事件配置方式：选择 使用长连接接收事件
[Image]
添加事件订阅，勾选以下事件：
事件
说明
im.message.receive_v1
接收消息（必需）
im.message.message_read_v1
消息已读回执
im.chat.member.bot.added_v1
机器人进群
im.chat.member.bot.deleted_v1
机器人被移出群
[Image]
 
[Image]
 
[Image]
 
[Image]
2. 重新设置OpenClaw
[Image]
 
[Image]
 
[Image]
 
[Image]
 
[Image]
 
[Image]
 
[Image]
 
[Image]
此外也可以考虑使用Kimi 2.5
[Image]
 
[Image]
- Gmail功能安装
[Image]
 
[Image]
 
[Image]
- 使用clawhub安装Skills
clawhub search "gmail"
clawhub install gmail
[Image]
- 下载内容
[Image]
 
[Image]
 
[Image]
 
[Image]
- 音频转文字功能实现
[Image]
[Image]
[Image]
[Image]
[Image]
 
[Image]
 
[Image]
 
[Image]
[Image]
[Image]
[Image]
[Image]
- PDF转MD功能开发
[Image]
---
name: pdf-resume-to-md
description: Convert a resume PDF (by filename) into a Markdown file with the same name using a local Python extractor. Supports deterministic output and extraction reports.

---

# **PDF Resume → Markdown**

Convert a specific resume PDF into Markdown by invoking a local Python script.

The PDF is identified **by filename**, resolved from a predefined resume directory, and saved as a .md file with the same base name.

Offline-only. No network access.

## Setup

1. **Install dependencies:**

   ```bash
   pip3 install pypdf
Or use the provided requirements.txt:
pip3 install -r requirements.txt
2. Optional (better PDF metadata): install poppler-utils / pdftotext
Input Convention
- Resume PDF directory: <RESUME_PDF_DIR>
- Markdown output directory: <RESUME_MD_DIR>
Example:
- Input filename: john_doe_resume.pdf
- Resolved input path: <RESUME_PDF_DIR>/john_doe_resume.pdf
- Output file: <RESUME_MD_DIR>/john_doe_resume.md
Convert Resume (Single PDF)
- Convert by filename:
python pdf_to_md.py --input <RESUME_PDF_DIR>/john_doe_resume.pdf --output <RESUME_MD_DIR>/john_doe_resume.md
Batch Conversion (Optional)
- Convert all PDFs in a directory:
python pdf_to_md.py --input <RESUME_PDF_DIR> --output <RESUME_MD_DIR> --recursive
Output Format
Each PDF produces exactly one Markdown file with the following structure:
- YAML frontmatter:
  - source_pdf
  - pages
  - extracted_chars
  - extraction_method
  - timestamp_utc
- Resume text body
- Page markers: <!-- page:N -->
- Extraction report (warnings, density, method)
Limitations
- No OCR.
- Image-only or scanned PDFs may yield empty text.
- A Markdown file is still produced with warnings.
Safety Notes
- Operates only on local files.
- No directory scanning beyond the resume root.
- No network access.
- No arbitrary shell execution.
Notes
- Validate the PDF filename exists before execution.
- Warn before overwriting an existing .md file.
- Do not assume text completeness for scanned resumes.

<img src="https://pictes.oss-cn-beijing.aliyuncs.com/LLM/image-20260203175320572.png" alt="image-20260203175320572" style="zoom:50%;" />

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from __future__ import annotations

import argparse
import datetime as dt
import fnmatch
import os
from pathlib import Path
from typing import Iterable, List, Tuple

from pypdf import PdfReader


def utc_now_iso() -> str:
    return dt.datetime.utcnow().replace(microsecond=0).isoformat() + "Z"


def is_pdf(path: Path) -> bool:
    return path.is_file() and path.suffix.lower() == ".pdf"


def iter_pdfs(input_path: Path, recursive: bool, glob_pat: str) -> Iterable[Path]:
    if input_path.is_file():
        if is_pdf(input_path):
            yield input_path
        return

    if not input_path.is_dir():
        return

    if recursive:
        for root, _, files in os.walk(input_path):
            for f in files:
                if fnmatch.fnmatch(f, glob_pat) and f.lower().endswith(".pdf"):
                    yield Path(root) / f
    else:
        for f in input_path.iterdir():
            if f.is_file() and fnmatch.fnmatch(f.name, glob_pat) and f.suffix.lower() == ".pdf":
                yield f


def extract_text_pypdf(pdf_path: Path) -> Tuple[str, int]:
    """
    Returns (text, pages)
    """
    reader = PdfReader(str(pdf_path))
    pages = len(reader.pages)
    chunks: List[str] = []
    for i, page in enumerate(reader.pages):
        try:
            t = page.extract_text() or ""
        except Exception:
            t = ""
        t = normalize_text(t)
        if t.strip():
            chunks.append(f"\n\n<!-- page:{i+1} -->\n\n{t}".strip())
    text = "\n\n".join(chunks).strip() + "\n"
    return text, pages


def normalize_text(s: str) -> str:
    # Keep it conservative: preserve newlines; normalize Windows newlines
    s = s.replace("\r\n", "\n").replace("\r", "\n")
    # Remove excessive trailing spaces per line
    s = "\n".join(line.rstrip() for line in s.splitlines())
    # Collapse 3+ blank lines to 2
    while "\n\n\n" in s:
        s = s.replace("\n\n\n", "\n\n")
    return s


def quality_warnings(text: str, pages: int) -> List[str]:
    warnings: List[str] = []
    chars = len(text.strip())
    if chars == 0:
        warnings.append("No extractable text found. PDF might be scanned/image-only (OCR needed).")
        return warnings

    # Text density heuristic
    density = chars / max(pages, 1)
    if density < 800:
        warnings.append(f"Low text density ({int(density)} chars/page). Might be heavily formatted or partially scanned.")
    if "�" in text:
        warnings.append("Found replacement characters (�). Encoding/extraction quality may be degraded.")
    return warnings


def md_frontmatter(source_pdf: Path, pages: int, extracted_chars: int, method: str) -> str:
    # Simple YAML; keep stable keys
    return (
        "---\n"
        f"source_pdf: \"{str(source_pdf)}\"\n"
        f"pages: {pages}\n"
        f"extracted_chars: {extracted_chars}\n"
        f"extraction_method: \"{method}\"\n"
        f"timestamp_utc: \"{utc_now_iso()}\"\n"
        "---\n"
    )


def build_markdown(source_pdf: Path, pages: int, text: str, method: str) -> str:
    extracted_chars = len(text.strip())
    fm = md_frontmatter(source_pdf, pages, extracted_chars, method)

    body = text.strip()
    if not body:
        body = "_(No extractable text was found in this PDF. It may be scanned; OCR is required.)_"

    warns = quality_warnings(text, pages)
    report_lines = [
        "\n\n---\n",
        "## Extraction report\n",
        f"- Pages: **{pages}**\n",
        f"- Extracted chars: **{extracted_chars}**\n",
        f"- Method: **{method}**\n",
    ]
    if warns:
        report_lines.append("- Warnings:\n")
        for w in warns:
            report_lines.append(f"  - {w}\n")
    else:
        report_lines.append("- Warnings: _(none)_\n")

    return fm + "\n" + body + "".join(report_lines)


def ensure_out_path(input_pdf: Path, out: Path) -> Path:
    """
    If out is a directory, place <pdf_stem>.md inside it.
    If out is a file path ending with .md, use it (single input only).
    """
    if out.suffix.lower() == ".md":
        return out
    out.mkdir(parents=True, exist_ok=True)
    return out / (input_pdf.stem + ".md")


def write_text(path: Path, content: str) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    path.write_text(content, encoding="utf-8")


def main() -> int:
    ap = argparse.ArgumentParser(
        description="Convert resume PDFs to Markdown (.md). Supports single PDF or directory batch."
    )
    ap.add_argument("--input", required=True, help="PDF file path OR directory containing PDFs")
    ap.add_argument("--output", required=True, help="Output .md file path OR output directory")
    ap.add_argument("--recursive", action="store_true", help="Recursively scan input directory")
    ap.add_argument("--glob", default="*.pdf", help="Glob pattern when input is a directory (default: *.pdf)")
    args = ap.parse_args()

    in_path = Path(args.input).expanduser().resolve()
    out_path = Path(args.output).expanduser().resolve()

    pdfs = list(iter_pdfs(in_path, args.recursive, args.glob))
    if not pdfs:
        print(f"[pdf_to_md] No PDFs found at: {in_path}")
        return 2

    # If output is a single .md file but we have multiple inputs, refuse
    if out_path.suffix.lower() == ".md" and len(pdfs) > 1:
        print("[pdf_to_md] --output is a file, but multiple PDFs were found. Use an output directory instead.")
        return 2

    ok = 0
    for pdf in pdfs:
        try:
            text, pages = extract_text_pypdf(pdf)
            md = build_markdown(pdf, pages, text, method="pypdf.extract_text")
            target = ensure_out_path(pdf, out_path)
            write_text(target, md)
            print(f"[pdf_to_md] OK: {pdf} -> {target} (pages={pages}, chars={len(text.strip())})")
            ok += 1
        except Exception as e:
            print(f"[pdf_to_md] FAIL: {pdf} ({type(e).__name__}: {e})")

    if ok == 0:
        return 1
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
[Image]
 
[Image]
- skills功能自优化
[Image]
[Image]
- 修改记忆
[Image]
- 编辑工作区中的引导文件（每次会话注入）：
  - SOUL.md：人格、语气与边界
  - IDENTITY.md：名称、风格与表情
  - USER.md：用户画像与称呼方式
  - AGENTS.md：操作指令、记忆使用规则与优先级
  - MEMORY.md：长期记忆（主会话专用）
[Image]
[Image]
[Image]
[Image]
[Image]
[Image]
 
[Image]
3. OpenClaw-HR实战测试
[Image]
- 简历发送
[Image]
- 简历接受
[Image]
- 简历处理
[Image]
实际服务器执行：
[Image]
- 信息整理
[Image]
 
[Image]
 
[Image]
 
[Image]
 
[Image]
- 多候选人对比
[Image]
 
[Image]
- 智能分析
[Image]
 
[Image]
 
[Image]
 
[Image]
 
[Image]
 
[Image]
 
[Image]
 
[Image]
 
[Image]
 
[Image]
 
[Image]
 
[Image]

---
- 体验课内容节选自《2026大模型Agent智能体开发实战》完整版付费课程
  体验课时间有限，若想深度学习大模型技术，欢迎大家报名由我主讲的《2026大模型Agent智能体开发实战》
[Image]
**《2026大模型Agent智能体开发实战》为【100+小时】体系大课，总共20大模块精讲精析，零基础直达大模型企业级应用！
课程完整介绍
[Image]
部分课程成果演示
- Fufan Manus通用智能体开发实战

- Coze自动图文视频创作流程

- 全自动数据清洗工作流

- NL2SQL数据分析Agent

- MiniChatGPT MCP Agent开发

- 垂域GraphRAG系统开发

- 智能文档审核Agent

- MateGen Pro 项目功能演示

- 智能客服项目展示

- GraphRAG+多模态文档检索

大模型秋季班封班特惠进行时，直播间享五折特价+全套SVIP新班特定福利，合购还有更多优惠哦~
[Image]
详细信息扫码添加助教，回复“大模型”，即可领取课程大纲&查看课程详情👇
[Image]
 
[Image]
 
[Image]
